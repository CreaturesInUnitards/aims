export const merge=(()=>{const e=(r,o,s)=>{const c=typeof s;if(s&&"object"===c)if(Array.isArray(s))for(const t of s)o=e(r,o,t);else for(const c of Object.keys(s)){const n=s[c];"function"==typeof n?o[c]=n(o[c],t):void 0===n?r&&!isNaN(c)?o.splice(c,1):delete o[c]:null===n||"object"!=typeof n||n.constructor!==Object||Array.isArray(n)?o[c]=n:"object"==typeof o[c]?o[c]=n===o[c]?n:t(o[c],n):o[c]=e(!1,{},n)}else"function"===c&&(o=s(o,t));return o},t=(t,...r)=>{const o=Array.isArray(t);return e(o,o?t.slice():Object.assign({},t),r)};return t})();export default({a:e=merge,i:t={},m:r=[e=>{}],s:o=!1}={})=>{let s=!1,c=e({},t);const n=t=>{c=e(c,t)},a=Object.assign({get:()=>c},!o&&{patch:n});a.redraw=t=>{if(!s){s=!0;const r=e;e=(e,o)=>(requestAnimationFrame((()=>{t(a)})),r(e,o)),t(a)}};const i=[r].flat().map((e=>e(a,o&&n)));return Object.freeze(Object.assign(a,...i))};