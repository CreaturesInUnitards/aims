const O=Object;O.a=O.assign;const A=Array.isArray;export const merge=(()=>{const t=(o,c,n)=>{const s=typeof n;if(n&&"object"===s)if(A(n))for(const e of n)c=t(o,c,e);else for(const s of O.keys(n)){const r=n[s];"function"==typeof r?c[s]=r(c[s],e):void 0===r?o&&!isNaN(s)?c.splice(s,1):delete c[s]:null===r||"object"!=typeof r||r.constructor!==O||A(r)?c[s]=r:"object"==typeof c[s]?c[s]=r===c[s]?r:e(c[s],r):c[s]=t(!1,{},r)}else"function"===s&&(c=n(c,e));return c},e=(e,...o)=>{const c=A(e);return t(c,c?e.slice():O.a({},e),o)};return e})();export default({a:t=merge,i:e={},m:o=[t=>{}],s:c=!1}={},n)=>{let s,r=t({},e);const f=e=>{r=t(r,e),n&&n(s)};s=O.a({get:()=>r},!c&&{patch:f});const a=[o].flat().map((t=>t(s,c&&f)));return O.a(s,...a),n&&n(s),O.freeze(s)};