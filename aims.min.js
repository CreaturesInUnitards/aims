const e=Object,t=e.assign,o=Array.isArray;export const merge=(()=>{const r=(t,n,s)=>{const f=typeof s;if(s&&"object"===f)if(o(s))for(const e of s)n=r(t,n,e);else for(const f of e.keys(s)){const i=s[f];"function"==typeof i?n[f]=i(n[f],c):void 0===i?t&&!isNaN(f)?n.splice(f,1):delete n[f]:null===i||"object"!=typeof i||i.constructor!==e||o(i)?n[f]=i:"object"==typeof n[f]?n[f]=i===n[f]?i:c(n[f],i):n[f]=r(!1,{},i)}else"function"===f&&(n=s(n,c));return n},c=(e,...c)=>{const n=o(e);return r(n,n?e.slice():t({},e),c)};return c})();export default({a:o=merge,i:r={},m:c=[e=>{}],s:n=!1}={})=>{let s=o({},r);const f=e=>{s=o(s,e)},i=t({get:()=>s},!n&&{patch:f}),l=[c].flat().map((e=>e(i,n&&f)));return e.freeze(t(i,...l))};